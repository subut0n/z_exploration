Graph/betweeness.go
package main

import "errors"

// BrandesShortestPaths calculates the shortest paths and number of shortest paths between all nodes in the graph using Brandes' algorithm
func (g *Graph) BrandesShortestPaths() (map[*Node]map[*Node][]*Node, map[*Node]map[*Node]int, error) {
	// Initialize paths and counts
	paths := make(map[*Node]map[*Node][]*Node)
	counts := make(map[*Node]map[*Node]int)

	for _, from := range g.Nodes {
		paths[from] = make(map[*Node][]*Node)
		counts[from] = make(map[*Node]int)

		for _, to := range g.Nodes {
			paths[from][to] = []*Node{}
			counts[from][to] = 0
		}
	}

	// BFS to find shortest paths and counts
	for _, s := range g.Nodes {
		S := []*Node{}
		P := make(map[*Node][]*Node)
		sigma := make(map[*Node]float64)
		d := make(map[*Node]int)

		for _, w := range g.Nodes {
			P[w] = []*Node{}
			sigma[w] = 0
			d[w] = -1
		}

		sigma[s] = 1
		d[s] = 0
		Q := []*Node{s}

		for len(Q) > 0 {
			v := Q[0]
			Q = Q[1:]
			S = append(S, v)

			for _, w := range g.Nodes {
				if d[w] < 0 && g.areLinked(v, w) {
					Q = append(Q, w)
					d[w] = d[v] + 1
				}
				if d[w] == d[v]+1 {
					sigma[w] += sigma[v]
					P[w] = append(P[w], v)
				}
			}
		}

		// Update paths and counts
		for _, t := range g.Nodes {
			paths[s][t] = P[t]
			counts[s][t] = int(sigma[t])
		}
	}

	return paths, counts, nil
}

// areLinked checks if two nodes are linked in the graph
func (g *Graph) areLinked(a, b *Node) bool {
	for _, link := range g.Links {
		if (link.From == a && link.To == b) || (link.From == b && link.To == a) {
			return true
		}
	}
	return false
}

// BetweennessCentrality computes the betweenness centrality of a given node in the graph
func (g *Graph) BetweennessCentrality(node *Node) (float64, error) {
	if node == nil {
		return 0, errors.New("node cannot be nil")
	}

	if err := g.CheckNodesExistence([]*Node{node}); err != nil {
		return 0, err
	}

	paths, counts, err := g.BrandesShortestPaths()
	if err != nil {
		return 0, err
	}

	n := len(g.Nodes)
	betweenness := 0.0

	for _, s := range g.Nodes {
		if s != node {
			for _, t := range g.Nodes {
				if t != node && t != s {
					shortestPaths := paths[s][t]
					shortestPathsWithNode := 0

					for _, path := range shortestPaths {
						for _, v := range path {
							if v == node {
								shortestPathsWithNode++
								break
							}
						}
					}

					fraction := float64(shortestPathsWithNode) / float64(counts[s][t])
					betweenness += fraction
				}
			}
		}
	}

	// Normalization
	if n > 2 {
		betweenness /= float64((n - 1) * (n - 2))
	}

	return betweenness, nil
}


--------------------

Graph/degree.go
package main

import "errors"

// DegreeCentrality computes the degree centrality of a given node in the graph
func (g *Graph) DegreeCentrality(node *Node) (float64, error) {
	if node == nil {
		return 0, errors.New("node cannot be nil")
	}

	if err := g.CheckNodesExistence([]*Node{node}); err != nil {
		return 0, err
	}

	degree := 0
	for _, link := range g.Links {
		if link.From == node || link.To == node {
			degree++
		}
	}

	return float64(degree), nil
}


--------------------

Graph/closeness.go
package main

import "errors"

// ShortestPaths calculates the shortest paths between all nodes in the graph using Floyd-Warshall algorithm
func (g *Graph) ShortestPaths() (map[*Node]map[*Node]int, error) {
	dist := make(map[*Node]map[*Node]int)

	// Initialize the distance map
	for _, from := range g.Nodes {
		dist[from] = make(map[*Node]int)
		for _, to := range g.Nodes {
			if from == to {
				dist[from][to] = 0
			} else {
				dist[from][to] = 1<<31 - 1 // Set a high initial value
			}
		}
	}

	// Set actual distance between linked nodes
	for _, link := range g.Links {
		dist[link.From][link.To] = 1
		dist[link.To][link.From] = 1
	}

	// Floyd-Warshall algorithm
	for _, k := range g.Nodes {
		for _, i := range g.Nodes {
			for _, j := range g.Nodes {
				if dist[i][k]+dist[k][j] < dist[i][j] {
					dist[i][j] = dist[i][k] + dist[k][j]
				}
			}
		}
	}

	return dist, nil
}

// ClosenessCentrality computes the closeness centrality of a given node in the graph
func (g *Graph) ClosenessCentrality(node *Node) (float64, error) {
	if node == nil {
		return 0, errors.New("node cannot be nil")
	}

	if err := g.CheckNodesExistence([]*Node{node}); err != nil {
		return 0, err
	}

	dist, err := g.ShortestPaths()
	if err != nil {
		return 0, err
	}

	sum := 0
	for _, to := range g.Nodes {
		if node != to {
			sum += dist[node][to]
		}
	}

	if sum == 0 {
		return 0, nil
	}

	n := len(g.Nodes) - 1
	closeness := float64(n) / float64(sum)

	return closeness, nil
}


--------------------

Graph/model.go
package main

import "time"

// Graph Node and Links

type Graph struct {
	Nodes []*Node
	Links []*Link
}

type Node struct {
	ID           string
	Type         string
	Neighbors    []*Node
	Data         interface{}
	CreationDate time.Time
	LastUpdate   time.Time
}

type Link struct {
	ID           string
	Type         string
	From         *Node
	To           *Node
	Data         interface{}
	CreationDate time.Time
	LastUpdate   time.Time
}

// Data

// Nodes Data

// Node: Profile - Type: Collaborator
type NodeProfileCollaboratorData struct {
	Scores    Scores // Centrality, Exposure, Threat Propagation, Risk, Awareness
	Community string // Community Detection ML
}

// Node: Profile - Type: Malicious
type NodeProfileMaliciousData struct {
}

// Node: Threat
type NodeThreatData struct {
	Action          string
	Folder          string
	From            string
	FromHeader      string
	ID              string
	LastReport      string
	LastReportDate  string
	MessageID       string
	RemediationIDs  []string
	RemediationType string
	SenderIP        string
	Size            string
	Status          string
	Subject         string
	Substatus       string
	To              string
	Header          string
	ToHeader        string
	URLs            string
	WhiteListed     string
}

// Links Data

// Link: Collaborator To Collaborator
type ColToColLinkData struct {
	MailCount int64
}

// Link: Malicious to Collaborator

// Scores

type Scores struct {
	Centrality Centrality
	// Exposure          Exposure
	// ThreatPropagation ThreatPropagation
	// Risk              Risk
	// Awareness         Awareness
}

type Centrality struct {
	Degree      float64
	Closeness   float64
	Betweenness float64
	Eigenvector float64
	PageRank    float64
	Katz        float64
	Subgraph    float64
}

// TO DO
type Exposure struct {
}

// TO DO
type ThreatPropagation struct {
}

// TO DO
type Risk struct {
}

// TO DO
type Awareness struct {
}


--------------------

Graph/main.go
package main

import (
	"errors"
	"fmt"
)

// TO DO:
// - Validators for data in nodes and links creation:
// 		Why?   - Insure data content
//		Where? - NewNode(), NewLink()
// - ID Incrementer in Node and Link creation:
// 		Why?   - Every Node and Link should have an unique ID
//		Where? - NewNode(), NewLink()

// WARNING: The use of interface for the data field induces validators IMPERATIVELY
// in order to have the insurance that the injected data is correct.
func NewNode(nodeType string, data interface{}) *Node {
	return &Node{
		Type: nodeType,
		Data: data,
	}
}

// WARNING: The use of interface for the data field induces validators IMPERATIVELY
// in order to have the insurance that the injected data is correct.
func (g *Graph) NewLink(linkType string, from, to *Node, data interface{}) (*Link, error) {
	if from == nil {
		return nil, errors.New("from node cannot be nil")
	}
	if to == nil {
		return nil, errors.New("to node cannot be nil")
	}
	if err := g.CheckNodesExistence([]*Node{from, to}); err != nil {
		return nil, err
	}
	return &Link{
		ID:   "",
		Type: linkType,
		From: from,
		To:   to,
		Data: data,
	}, nil
}

// Add Node(s) to Graph
func (g *Graph) AddNodeToGraph(n *Node) error {
	if n == nil {
		return errors.New("node cannot be nil")
	}
	g.Nodes = append(g.Nodes, n)
	return nil
}

func (g *Graph) AddMultipleNodesToGraph(nodes []*Node) error {
	if len(nodes) == 0 {
		return errors.New("nodes slice cannot be empty")
	}
	for _, node := range nodes {
		err := g.AddNodeToGraph(node)
		if err != nil {
			return err
		}
	}
	return nil
}

// Add Link to the Graph
func (g *Graph) AddLinkToGraph(l *Link) error {
	if l == nil {
		return errors.New("link cannot be nil")
	}
	g.Links = append(g.Links, l)
	return nil
}

// Add multiple links to the Graph
func (g *Graph) AddMultipleLinksToGraph(links []*Link) error {
	if len(links) == 0 {
		return errors.New("links slice cannot be empty")
	}
	for _, link := range links {
		err := g.AddLinkToGraph(link)
		if err != nil {
			return err
		}
	}
	return nil
}

// CHECKERS

// CheckNodesExistence in the Graph
func (g *Graph) CheckNodesExistence(nodes []*Node) error {
	nodeMap := make(map[*Node]bool)
	for _, node := range g.Nodes {
		nodeMap[node] = true
	}
	for _, node := range nodes {
		if _, ok := nodeMap[node]; !ok {
			return fmt.Errorf("node %v not found in graph", node)
		}
	}
	return nil
}

// Check Nodes existence in the Graph with their IDs
func (g *Graph) CheckNodesExistenceWithIDs(nodeIDs []string) error {
	nodeMap := make(map[string]bool)
	for _, node := range g.Nodes {
		nodeMap[node.ID] = true
	}
	for _, id := range nodeIDs {
		if _, ok := nodeMap[id]; !ok {
			return fmt.Errorf("node with ID %s not found in graph", id)
		}
	}
	return nil
}


--------------------

