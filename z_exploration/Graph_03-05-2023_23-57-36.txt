Graph/validator.go
package main

import "errors"

func ValidateNodeData(data interface{}) error {
	switch data := data.(type) {
	case *NodeProfileCollaboratorData:
		// add validation for inbound and outbound interactions
		if data.Inbound.InteractionsFromCollaborator < 0 {
			return errors.New("inbound interactions cannot be negative")
		}
		if data.Outbound.InteractionsToCollaborator < 0 {
			return errors.New("outbound interactions cannot be negative")
		}
		return nil
	case *NodeProfileMaliciousData, *NodeThreatData:
		return nil
	default:
		return errors.New("unsupported data type")
	}
}

func ValidateLinkData(data interface{}) error {
	switch data.(type) {
	case *ColToColLinkData:
		return nil
	default:
		return errors.New("unsupported link data type")
	}
}


--------------------

Graph/graph.go
package main

import (
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
)

// TO DO:
// - Validators for data in nodes and links creation:
// 		Why?   - Insure data content
//		Where? - NewNode(), NewLink()
// - ID Incrementer in Node and Link creation:
// 		Why?   - Every Node and Link should have an unique ID
//		Where? - NewNode(), NewLink()

func NewGraph() *Graph {
	return &Graph{
		Nodes: []*Node{},
		Links: []*Link{},
	}
}

// WARNING: The use of interface for the data field induces validators IMPERATIVELY
// in order to have the insurance that the injected data is correct.
func NewNode(nodeType string, data interface{}) (*Node, error) {
	err := ValidateNodeData(data)
	if err != nil {
		return nil, err
	}

	id, err := uuid.NewRandom()
	if err != nil {
		return nil, err
	}

	// set inbound and outbound interactions to 0
	switch data := data.(type) {
	case *NodeProfileCollaboratorData:
		data.Inbound.InteractionsFromCollaborator = 0
		data.Outbound.InteractionsToCollaborator = 0
	}

	return &Node{
		ID:           id,
		Type:         nodeType,
		Neighbors:    []*Node{},
		Data:         data,
		CreationDate: time.Now(),
		LastUpdate:   time.Now(),
	}, nil
}

// WARNING: The use of interface for the data field induces validators IMPERATIVELY
// in order to have the insurance that the injected data is correct.
func (g *Graph) NewLink(linkType string, from, to *Node, data interface{}) (*Link, error) {
	err := ValidateLinkData(data)
	if err != nil {
		return nil, err
	}

	if from == to {
		return nil, errors.New("from node and to node cannot be the same")
	}
	if err := g.CheckNodesExistence([]*Node{from, to}); err != nil {
		return nil, err
	}

	id, err := uuid.NewRandom()
	if err != nil {
		return nil, err
	}

	return &Link{
		ID:           id.String(),
		Type:         linkType,
		From:         from,
		To:           to,
		Data:         data,
		CreationDate: time.Now(),
		LastUpdate:   time.Now(),
	}, nil
}

func (g *Graph) AddNodeToGraph(n *Node) error {
	if n == nil {
		return errors.New("node cannot be nil")
	}
	g.Nodes = append(g.Nodes, n)
	return nil
}

func (g *Graph) AddMultipleNodesToGraph(nodes []*Node) error {
	if len(nodes) == 0 {
		return errors.New("nodes slice cannot be empty")
	}
	for _, node := range nodes {
		err := g.AddNodeToGraph(node)
		if err != nil {
			return err
		}
	}
	return nil
}

func (g *Graph) AddLinkToGraph(l *Link) error {
	if l == nil {
		return errors.New("link cannot be nil")
	}
	g.UpdateInteractions(l)
	g.Links = append(g.Links, l)
	return nil
}

func (g *Graph) AddMultipleLinksToGraph(links []*Link) error {
	if len(links) == 0 {
		return errors.New("links slice cannot be empty")
	}
	for _, link := range links {
		err := g.AddLinkToGraph(link)
		if err != nil {
			return err
		}
	}
	return nil
}

// CHECKERS

func (g *Graph) CheckNodeExistence(node *Node) error {
	for _, n := range g.Nodes {
		if n == node {
			return nil
		}
	}
	return fmt.Errorf("node %v not found in graph", node)
}

func (g *Graph) CheckNodesExistence(nodes []*Node) error {
	nodeMap := make(map[*Node]bool)
	for _, node := range g.Nodes {
		nodeMap[node] = true
	}
	for _, node := range nodes {
		if _, ok := nodeMap[node]; !ok {
			return fmt.Errorf("node %v not found in graph", node)
		}
	}
	return nil
}

func (g *Graph) CheckNodeWithID(id uuid.UUID) error {
	for _, node := range g.Nodes {
		if node.ID == id {
			return nil
		}
	}
	return fmt.Errorf("node with ID %v not found in graph", id)
}

func (g *Graph) CheckNodesExistenceWithIDs(nodeIDs []uuid.UUID) error {
	nodeMap := make(map[uuid.UUID]bool)
	for _, node := range g.Nodes {
		nodeMap[node.ID] = true
	}
	for _, id := range nodeIDs {
		if _, ok := nodeMap[id]; !ok {
			return fmt.Errorf("node with ID %v not found in graph", id)
		}
	}
	return nil
}


--------------------

Graph/generator.go
package main

import (
	"errors"
	"math/rand"
)

// GenerateRandomGraph generates a random graph with the specified number of nodes and links.
// The generated graph will have 250 nodes and 5000 links, where each link has a randomly generated
// Interactions.Total value between 10 and 50.
func GenerateRandomGraph(numNodes, numLinks int) (*Graph, error) {
	if numNodes <= 0 {
		return nil, errors.New("number of nodes should be greater than 0")
	}
	if numLinks <= 0 {
		return nil, errors.New("number of links should be greater than 0")
	}

	// Création d'un nouveau graph vide
	graph := NewGraph()

	// Création de nodes avec un type "profil collaborator"
	for i := 1; i <= numNodes; i++ {
		nodeData := &NodeProfileCollaboratorData{
			Scores: Scores{
				Centrality: Centrality{
					Degree:      0,
					Closeness:   0,
					Betweenness: 0,
					Eigenvector: 0,
					PageRank:    0,
				},
			},
			Community: "",
		}
		node, err := NewNode("profil", nodeData)
		if err != nil {
			return nil, err
		}
		graph.AddNodeToGraph(node)
	}

	// Création de liens "collaborator to collaborator" de manière aléatoire
	for i := 1; i <= numLinks; i++ {
		fromIndex := rand.Intn(numNodes)
		toIndex := rand.Intn(numNodes)
		if fromIndex == toIndex {
			toIndex = rand.Intn(numNodes)
		}

		fromNode := graph.Nodes[fromIndex]
		toNode := graph.Nodes[toIndex]

		interactions := Interactions{
			Total: rand.Int63n(40) + 10, // Interaction totale entre 10 et 50
		}

		linkData := &ColToColLinkData{
			Interactions: interactions,
		}

		link, err := graph.NewLink("CollaboratorToCollaborator", fromNode, toNode, linkData)
		if err != nil {
			return nil, err
		}
		err = graph.AddLinkToGraph(link)
		if err != nil {
			return nil, err
		}
	}

	return graph, nil
}

// GenerateRandomGraph generates a random graph with the specified number of nodes and links.
// The generated graph will have 250 nodes and 5000 links, where each link has a randomly generated
// Interactions.Total value between 10 and 50.
func ATestgenerate(numNodes, numLinks int) (*Graph, error) {
	if numNodes < 1 {
		return nil, errors.New("invalid number of nodes, must be at least 1")
	}

	if numLinks < numNodes-1 {
		return nil, errors.New("invalid number of links, must be at least (numNodes-1)")
	}

	g := NewGraph()

	// create nodes
	for i := 0; i < numNodes; i++ {
		nodeData := &NodeProfileCollaboratorData{
			Scores: Scores{
				Centrality: Centrality{
					Degree:      0,
					Closeness:   0,
					Betweenness: 0,
					Eigenvector: 0,
					PageRank:    0,
				},
			},
			Community: "",
		}
		node, err := NewNode("profile", nodeData)
		if err != nil {
			return nil, err
		}
		err = g.AddNodeToGraph(node)
		if err != nil {
			return nil, err
		}
	}

	// create links
	linkData := &ColToColLinkData{}
	for i := 0; i < numLinks; i++ {
		from := rand.Intn(numNodes)
		to := rand.Intn(numNodes)

		for to == from {
			to = rand.Intn(numNodes)
		}

		linkData.Interactions.Total = int64(rand.Intn(40) + 10) // generate random Interactions.Total value between 10 and 50
		link, err := g.NewLink("CollaboratorToCollaborator", g.Nodes[from], g.Nodes[to], linkData)
		if err != nil {
			return nil, err
		}
		err = g.AddLinkToGraph(link)
		if err != nil {
			return nil, err
		}
	}

	return g, nil
}


--------------------

Graph/file.go
package main

import (
	"encoding/json"
	"errors"
	"os"
)

const jsonFileName = "graph_data.json"

func SaveGraphToFile(g *Graph) error {
	if g == nil {
		return errors.New("graph cannot be nil")
	}

	file, err := os.Create(jsonFileName)
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	err = encoder.Encode(g)
	if err != nil {
		return err
	}

	return nil
}

func LoadGraphFromFile(filename string) (*Graph, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var g Graph
	decoder := json.NewDecoder(file)
	err = decoder.Decode(&g)
	if err != nil {
		return nil, err
	}

	return &g, nil
}


--------------------

Graph/model.go
package main

import (
	"time"

	"github.com/google/uuid"
)

// Graph Node and Links

type Graph struct {
	Nodes []*Node
	Links []*Link
}

type Node struct {
	ID           uuid.UUID
	Type         string
	Neighbors    []*Node
	Data         interface{}
	CreationDate time.Time
	LastUpdate   time.Time
}

type Link struct {
	ID           string
	Type         string
	From         *Node
	To           *Node
	Data         interface{}
	CreationDate time.Time
	LastUpdate   time.Time
}

// Data

// Nodes Data

// Node: Profile - Type: Collaborator
// Node: Profile - Type: Collaborator
type NodeProfileCollaboratorData struct {
	Scores    Scores   // Centrality, Exposure, Threat Propagation, Risk, Awareness
	Community string   // Community Detection ML
	Inbound   Inbound  // Number of interactions received from other collaborators
	Outbound  Outbound // Number of interactions sent to other collaborators
}
type Inbound struct {
	InteractionsFromCollaborator int64 // Number of interactions received from other collaborators
	FromCollaborator             int64 // Number of collaborators
}

type Outbound struct {
	InteractionsToCollaborator int64 // Number of interactions sent to other collaborators
	ToCollaborators            int64 // Number of collaborators
}

// Node: Profile - Type: Malicious
type NodeProfileMaliciousData struct {
}

// Node: Threat
type NodeThreatData struct {
	Action          string
	Folder          string
	From            string
	FromHeader      string
	ID              string
	LastReport      string
	LastReportDate  string
	MessageID       string
	RemediationIDs  []string
	RemediationType string
	SenderIP        string
	Size            string
	Status          string
	Subject         string
	Substatus       string
	To              string
	Header          string
	ToHeader        string
	URLs            string
	WhiteListed     string
}

// Links Data

// Link: Collaborator To Collaborator
type ColToColLinkData struct {
	Interactions Interactions // Mails
}

type Interactions struct {
	Total int64 // For now will represent the weight
	// ...
}

// Link: Malicious to Collaborator

// Scores

type Scores struct {
	Centrality Centrality
	// Exposure          Exposure
	// ThreatPropagation ThreatPropagation
	// Risk              Risk
	// Awareness         Awareness
}

type Centrality struct {
	Degree      float64
	Closeness   float64
	Betweenness float64
	Eigenvector float64
	PageRank    float64
}

// TO DO
type Exposure struct {
}

// TO DO
type ThreatPropagation struct {
}

// TO DO
type Risk struct {
}

// TO DO
type Awareness struct {
}


--------------------

Graph/main.go
package main

import (
	"fmt"

	"github.com/google/uuid"
)

func (g *Graph) PrintGraph() {
	nodeIDs := make(map[uuid.UUID]bool)
	for _, node := range g.Nodes {
		nodeIDs[node.ID] = true
	}

	for _, node := range g.Nodes {
		fmt.Printf("Node %v (%s) %v:\n", node.ID, node.Type, node.Data)
		count := 0
		for _, link := range g.Links {
			if link.From.ID == node.ID {
				count++
				fmt.Printf("\t-> %s (%v)\n", link.To.Type, link.To.ID)
			}
		}
		fmt.Printf("Links number for this node %d\n", count)
		fmt.Println()
	}

	for _, node := range g.Nodes {
		if _, ok := nodeIDs[node.ID]; !ok {
			fmt.Printf("Node %v (%s):\n", node.ID, node.Type)
			fmt.Println("\t-> no links")
			fmt.Println()
		}
	}
}

func main() {
	graph, err := GenerateRandomGraph(10, 100)
	if err != nil {
		fmt.Println("Error generating random graph:", err)
		return
	}

	graph.PrintGraph()

	// // Save graph as a JSON file
	// err = SaveGraphToFile(graph)
	// if err != nil {
	// 	fmt.Println("Error saving graph to file:", err)
	// 	return
	// }

	// // Loag graph from file
	// loadedGraph, err := LoadGraphFromFile("graph_data.json")
	// if err != nil {
	// 	fmt.Println("Error loading graph from file:", err)
	// 	return
	// }
	// loadedGraph.PrintGraph()

	fmt.Printf("Nombre de nodes dans le graph charge: %d\n", len(graph.Nodes))
	fmt.Printf("Nombre de links dans le graph charge: %d\n", len(graph.Links))

}


--------------------

Graph/interactions.go
package main

func (g *Graph) UpdateInteractions(link *Link) {
	if link == nil {
		return
	}

	fromNodeData, ok := link.From.Data.(*NodeProfileCollaboratorData)
	if ok {
		fromNodeData.Outbound.InteractionsToCollaborator += link.Data.(*ColToColLinkData).Interactions.Total
	}

	toNodeData, ok := link.To.Data.(*NodeProfileCollaboratorData)
	if ok {
		toNodeData.Inbound.InteractionsFromCollaborator += link.Data.(*ColToColLinkData).Interactions.Total
	}
}


--------------------

