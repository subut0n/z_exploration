Graph/model.go
package main

// Graph Node and Links

type Graph struct {
	Nodes []*Node
	Links []*Link
}

type Node struct {
	ID        string
	Type      string
	Neighbors []*Node
	Data      interface{}
}

type Link struct {
	ID   string
	Type string
	From *Node
	To   *Node
	Data interface{}
}

// Data

// Nodes Data

// Node: Threat
type NodeThreatData struct {
}

// Node: Profile - Type: Collaborator
type NodeProfileCollaboratorData struct {
}

// Node: Profile - Type: Malicious
type NodeProfileMaliciousData struct {
}

// Scores

type Scores struct {
	Centrality Centrality
	// Exposure          Exposure
	// ThreatPropagation ThreatPropagation
	// Risk              Risk
	// Awareness         Awareness
}

type Centrality struct {
	Degree      float64
	Closeness   float64
	Betweenness float64
	Eigenvector float64
	PageRank    float64
	Katz        float64
	Subgraph    float64
}

// TO DO
type Exposure struct {
}

// TO DO
type ThreatPropagation struct {
}

// TO DO
type Risk struct {
}

// TO DO
type Awareness struct {
}


--------------------

Graph/main.go
package main

import (
	"errors"
	"fmt"
)

// TO DO:
// - Validators for data in nodes and links creation:
// 		Why?   - Insure data content
//		Where? - NewNode(), NewLink()
// - ID Incrementer in Node and Link creation:
// 		Why?   - Every Node and Link should have an unique ID
//		Where? - NewNode(), NewLink()

// WARNING: The use of interface for the data field induces validators IMPERATIVELY
// in order to have the insurance that the injected data is correct.
// Check TO DO
func (g *Graph) NewNode(nodeType string, data interface{}) *Node {
	return &Node{
		Type: nodeType,
		Data: data,
	}
}

// WARNING: The use of interface for the data field induces validators IMPERATIVELY
// in order to have the insurance that the injected data is correct.
// Check TO DO
func (g *Graph) NewLink(linkType string, from, to *Node, data interface{}) (*Link, error) {
	if from == nil {
		return nil, errors.New("from node cannot be nil")
	}
	if to == nil {
		return nil, errors.New("to node cannot be nil")
	}
	if err := g.CheckNodesExistence([]*Node{from, to}); err != nil {
		return nil, err
	}
	return &Link{
		ID:   "",
		Type: linkType,
		From: from,
		To:   to,
		Data: data,
	}, nil
}

// Add Node(s) to Graph
func (g *Graph) AddNodeToGraph(n *Node) error {
	if n == nil {
		return errors.New("node cannot be nil")
	}
	g.Nodes = append(g.Nodes, n)
	return nil
}

func (g *Graph) AddMultipleNodesToGraph(nodes []*Node) error {
	if len(nodes) == 0 {
		return errors.New("nodes slice cannot be empty")
	}
	for _, node := range nodes {
		err := g.AddNodeToGraph(node)
		if err != nil {
			return err
		}
	}
	return nil
}

// Add Link to the Graph
func (g *Graph) AddLinkToGraph(l *Link) error {
	if l == nil {
		return errors.New("link cannot be nil")
	}
	g.Links = append(g.Links, l)
	return nil
}

// Add multiple links to the Graph
func (g *Graph) AddMultipleLinksToGraph(links []*Link) error {
	if len(links) == 0 {
		return errors.New("links slice cannot be empty")
	}
	for _, link := range links {
		err := g.AddLinkToGraph(link)
		if err != nil {
			return err
		}
	}
	return nil
}

// CHECKERS

// CheckNodesExistence in the Graph
func (g *Graph) CheckNodesExistence(nodes []*Node) error {
	nodeMap := make(map[*Node]bool)
	for _, node := range g.Nodes {
		nodeMap[node] = true
	}
	for _, node := range nodes {
		if _, ok := nodeMap[node]; !ok {
			return fmt.Errorf("node %v not found in graph", node)
		}
	}
	return nil
}

// Check Nodes existence in the Graph with their IDs
func (g *Graph) CheckNodesExistenceWithIDs(nodeIDs []string) error {
	nodeMap := make(map[string]bool)
	for _, node := range g.Nodes {
		nodeMap[node.ID] = true
	}
	for _, id := range nodeIDs {
		if _, ok := nodeMap[id]; !ok {
			return fmt.Errorf("node with ID %s not found in graph", id)
		}
	}
	return nil
}


--------------------

